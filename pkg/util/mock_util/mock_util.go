// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/util/iptables.go

// Package mock_util is a generated GoMock package.
package mock_util

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockIptables is a mock of Iptables interface
type MockIptables struct {
	ctrl     *gomock.Controller
	recorder *MockIptablesMockRecorder
}

// MockIptablesMockRecorder is the mock recorder for MockIptables
type MockIptablesMockRecorder struct {
	mock *MockIptables
}

// NewMockIptables creates a new mock instance
func NewMockIptables(ctrl *gomock.Controller) *MockIptables {
	mock := &MockIptables{ctrl: ctrl}
	mock.recorder = &MockIptablesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIptables) EXPECT() *MockIptablesMockRecorder {
	return m.recorder
}

// ClearChain mocks base method
func (m *MockIptables) ClearChain(table, chain string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearChain", table, chain)
	ret0, _ := ret[0].(error)
	return ret0
}

// ClearChain indicates an expected call of ClearChain
func (mr *MockIptablesMockRecorder) ClearChain(table, chain interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearChain", reflect.TypeOf((*MockIptables)(nil).ClearChain), table, chain)
}

// AppendUnique mocks base method
func (m *MockIptables) AppendUnique(table, chain string, rule ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{table, chain}
	for _, a := range rule {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendUnique", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AppendUnique indicates an expected call of AppendUnique
func (mr *MockIptablesMockRecorder) AppendUnique(table, chain interface{}, rule ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table, chain}, rule...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendUnique", reflect.TypeOf((*MockIptables)(nil).AppendUnique), varargs...)
}

// Exists mocks base method
func (m *MockIptables) Exists(table, chain string, rule ...string) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{table, chain}
	for _, a := range rule {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exists", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists
func (mr *MockIptablesMockRecorder) Exists(table, chain interface{}, rule ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table, chain}, rule...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockIptables)(nil).Exists), varargs...)
}
